---
layout:     post
title:      java虚拟机垃圾回收以及类加载机制
subtitle:   那些需要掌握的java知识
date:       2017-05-07
author:     Booker
header-img: img/rookie.jpg
catalog: true
tags:
    - JAVA
    - 垃圾回收
    - 类加载

---


> 本文首次发布于 [BookerBlog](http://stephengiant.github.io), 作者 [@Booker](http://github.com/StephenGiant) ,转载请保留原文链接.

## 一、Java虚拟机的内存分区

根据《Java虚拟机规范（Java SE 7版）》的规定，java虚拟机管理的内存共分为这几个运行时数据区域：

### 1、程序计数器

它是一块较小的内存空间，可以当作是当前线程所执行的字节码的行号指示器，也就是我们写代码时所遇见的程序执行顺序登的调度（包括分支、循环、跳转等）。在Java中，虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任意确定时刻，一个处理器（或者一个核心）都只会执行一条线程中的指令。所以，为了线程切换后能恢复到原先的正确执行位置，每条线程都要有一个自己独立的程序计数器。

需要注意的是，执行的是Java的方法的话，程序计数器记录的是正在执行的虚拟机字节码指令的地址，而如果是Native的方法，这个计数器值为空。

程序计数器是Java虚拟机内存分区里唯一一个不抛出OOM异常的分区。

### 2、Java虚拟机栈

Java虚拟机栈也是线程私有的，它的生命周期与线程相同。它可以作为一个GCRoot（在后面垃圾回收再详谈）。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

```kotlin
fun stackTest():String{
    var variable = String("aaa".toByteArray(), Charset.forName("UTF-8"))
    return aaa
}
```

**局部变量表(Local Variable Table)**是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。方法中的variable就是在局部变量表里的一个局部变量。

**操作数栈(Operand Stack)**也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。

当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。

在stackTest方法中，共有两行代码，他们的操作过程就包含了出栈入栈，都会在操作数栈中记录。

在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。

Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的**动态连接(Dynamic Linking)**。

这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为**静态解析**。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。

在引用举例的方法中，String("aaa".toByteArray(), Charset.forName("UTF-8"))就是一个动态链接。

在虚拟机栈分区中，规定了两种异常。一是StackOverFlow异常，二是OutOfMemoryError异常。栈深度异常我们在使用递归方法没有做好递归出口的时候，会触发它，而内存溢出异常，则常常是因为我们设计的代码使用的内存过高导致的。

### 3、Java堆

Java堆是Java虚拟机所管理的内存中最大的一块，而且他不是线程独有的，能被所有线程共享。（想想也是，如果他不能共享，那多线程操作意义就不大了）Java堆存在的唯一意义就是存放对象。

Java堆是垃圾收集器管理的主要区域。正是因为Java堆比较大，所以这个堆还往往被分为新生代老年代等

此分区也会抛出OutOfMemoryError。

### 4、方法区

方法区也是各个线程共享等内存分区。方法区主要用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据

#### 运行时常量池

它是方法区的一部分，主要用于存放各种常量

### 5、直接内存

它属于堆外内存。在Java的SDK中，有一个叫做NIO的类，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。他这么做的目的是为了避免在Java堆和Native堆中来回复制数据。

## 二、虚拟机垃圾回收

### 1、垃圾判断机制

Java虚拟机设计的是可达性分析算法来判断是否为垃圾对象的。它的基本思路就是从GCRoots往下搜索，根据对象的引用链，来查看此对象与GCRoots是否有相连的引用链。如果一个对象它到GCRoots的引用链中间是断开的，那么则认为它是“不可用”的，就可以标记为垃圾对象，即可回收对象。

在Java语言中，共定义了4种可作为GCRoots的对象：

1、虚拟机栈中引用的对象

从前面我们可以了解到，虚拟机栈的生命周期是与线程同步的，也就是说当对象与这个线程有引用链的时候，它的引用是可用的，那么它将不会被当作垃圾来回收。

在Android中，如果直接创建一个Handler是会有内存泄漏警告的，这是为什么呢？我们默认的Handler，是绑定的主线程的Looper，这些可以在ActivityMainThrad源码中找到。当我们的一个Activity销毁后，也就意味着这个Activity是要与GCRoots切段引用链了的，而如果我们的handler是直接new的 就会因为它不是一个垃圾而影响它的销毁，这就造成了额外的内存开销。

2、方法区中类静态属性引用的对象

我们常用的单例模式往往会使用静态变量，所以使用单例模式的时候要注意用完的对象是否还与单例对象有引用。

3、方法区中常量引用的对象

4、本地方法栈中JNI的对象

配合Java的垃圾回收机制，Java还规定了4种引用类型，强引用、软引用、弱引用以及虚引用。

强引用就是我们前面谈到的那种回收机制，根据引用链来，而软引用的对象可以在内存不足的时候，被回收。弱引用在GC到来的时候一定会被回收。最后，虚引用，又称为影子引用，本身不会影响一个对象的生命周期，也无法通过它去拿到一个实例，仅仅是作为反应一个对象是否被回收了。

## 三、类加载机制