---
layout:     post
title:      java虚拟机垃圾回收以及类加载机制
subtitle:   那些需要掌握的java知识
date:       2017-05-07
author:     Booker
header-img: img/rookie.jpg
catalog: true
tags:
    - JAVA
    - 垃圾回收
    - 类加载

---


> 本文首次发布于 [BookerBlog](http://stephengiant.github.io), 作者 [@Booker](http://github.com/StephenGiant) ,转载请保留原文链接.

## 一、Java虚拟机的内存分区

根据《Java虚拟机规范（Java SE 7版）》的规定，java虚拟机管理的内存共分为这几个运行时数据区域：

### 1、程序计数器

它是一块较小的内存空间，可以当作是当前线程所执行的字节码的行号指示器，也就是我们写代码时所遇见的程序执行顺序登的调度（包括分支、循环、跳转等）。在Java中，虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任意确定时刻，一个处理器（或者一个核心）都只会执行一条线程中的指令。所以，为了线程切换后能恢复到原先的正确执行位置，每条线程都要有一个自己独立的程序计数器。

需要注意的是，执行的是Java的方法的话，程序计数器记录的是正在执行的虚拟机字节码指令的地址，而如果是Native的方法，这个计数器值为空。

程序计数器是Java虚拟机内存分区里唯一一个不抛出OOM异常的分区。

### 2、Java虚拟机栈

Java虚拟机栈也是线程私有的，它的生命周期与线程相同。它可以作为一个GCRoot（在后面垃圾回收再详谈）。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

```kotlin
fun stackTest():String{
    var variable = String("aaa".toByteArray(), Charset.forName("UTF-8"))
    return aaa
}
```

**局部变量表(Local Variable Table)**是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。方法中的variable就是在局部变量表里的一个局部变量。

**操作数栈(Operand Stack)**也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。

当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。

在stackTest方法中，共有两行代码，他们的操作过程就包含了出栈入栈，都会在操作数栈中记录。

在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。

Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的**动态连接(Dynamic Linking)**。

这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为**静态解析**。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。

在引用举例的方法中，String("aaa".toByteArray(), Charset.forName("UTF-8"))就是一个动态链接。

在虚拟机栈分区中，规定了两种异常。一是StackOverFlow异常，二是OutOfMemoryError异常。栈深度异常我们在使用递归方法没有做好递归出口的时候，会触发它，而内存溢出异常，则常常是因为我们设计的代码使用的内存过高导致的。

### 3、Java堆

Java堆是Java虚拟机所管理的内存中最大的一块，而且他不是线程独有的，能被所有线程共享。（想想也是，如果他不能共享，那多线程操作意义就不大了）Java堆存在的唯一意义就是存放对象。

Java堆是垃圾收集器管理的主要区域。正是因为Java堆比较大，所以这个堆还往往被分为新生代老年代等

此分区也会抛出OutOfMemoryError。

### 4、方法区

方法区也是各个线程共享等内存分区。方法区主要用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据

#### 运行时常量池

它是方法区的一部分，主要用于存放各种常量

### 5、本地方法栈

主要是和native的方法和引用有关，这里不作详细介绍

### 6、直接内存

它属于堆外内存。在Java的SDK中，有一个叫做NIO的类，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。他这么做的目的是为了避免在Java堆和Native堆中来回复制数据。

## 二、虚拟机垃圾回收

### 1、垃圾判断机制

Java虚拟机设计的是可达性分析算法来判断是否为垃圾对象的。它的基本思路就是从GCRoots往下搜索，根据对象的引用链，来查看此对象与GCRoots是否有相连的引用链。如果一个对象它到GCRoots的引用链中间是断开的，那么则认为它是“不可用”的，就可以标记为垃圾对象，即可回收对象。

在Java语言中，共定义了4种可作为GCRoots的对象：

**1、虚拟机栈中引用的对象**

从前面我们可以了解到，虚拟机栈的生命周期是与线程同步的，也就是说当对象与这个线程有引用链的时候，它的引用是可用的，那么它将不会被当作垃圾来回收。

在Android中，如果直接创建一个Handler是会有内存泄漏警告的，这是为什么呢？我们默认的Handler，是绑定的主线程的Looper，这些可以在ActivityMainThrad源码中找到。当我们的一个Activity销毁后，也就意味着这个Activity是要与GCRoots切段引用链了的，而如果我们的handler是直接new的 就会因为它不是一个垃圾而影响它的销毁，这就造成了额外的内存开销。根本原因就是内部类持有外部类的引用，而我们的内部类handler却是和GCRoot有引用链的，就类似于我们要删除一个文件夹，里面有文件却是正在访问而导致我们不能删除这个文件夹一样，因为这个文件与我们的“根引用”有引用关系。

**2、方法区中类静态属性引用的对象**

我们常用的单例模式往往会使用静态变量，所以使用单例模式的时候要注意用完的对象是否还与单例对象有引用。

**3、方法区中常量引用的对象**

**4、本地方法栈中JNI的对象或方法（或者说是native）**

主要是因为对native的具体实现java层是不知晓的，所以把这个作为根引用避免意外。

配合Java的垃圾回收机制，Java还规定了4种引用类型，强引用、软引用、弱引用以及虚引用。

强引用就是我们前面谈到的那种回收机制，根据引用链来，而软引用的对象可以在内存不足的时候，被回收。弱引用在GC到来的时候一定会被回收。最后，虚引用，又称为影子引用，本身不会影响一个对象的生命周期，也无法通过它去拿到一个实例，仅仅是作为反应一个对象是否被回收了。

### 2、垃圾回收算法

虚拟机主要使用的有三种垃圾回收算法，即标记-清除算法，标记-整理算法，复制算法。

**1、标记清除算法**

标记清除算法，很明显，就是把不可回收的对象添加一个标记，然后虚拟机统一清理内存分区。

标记和清除这两个过程的效率都不是很高，所以这种算法的效率并不高。标记清除算法在清除掉可回收对象后，由于清空的内存区域往往是不连续的，会导致内存碎片的产生。比如0x01区和0x03区都是有对象的，而如果一个对象的内存占用大于0x02的容量，就会浪费这区域的内存。

**2、标记整理算法**

不同于标记清除算法，标记整理算法将不可回收的对象统一移动到连续的内存区域，然后对可回收区域的内存统一去清理。

**3、复制算法**

复制算法区别去前面的算法，复制算法是将内存分为两个区域，一半作为幸存者区，另一半作为对象的存储区。当GC来临的时候，将可用的对象复制到幸存者区，然后直接清除创建对象内存分区的所有对象，这个算法效率很高，缺点就是比较耗内存，需要专门空出一片区域来复制对象。

**Java虚拟机的垃圾回收算法**

三种算法各有优缺点，其中效率最高的是复制算法，但是他对内存的开销比较大，所以java虚拟机为了使用复制算法去提高GC的效率，使用了分代的方式去存储对象。分代指的是存储对象的时候分为新生代（又称伊甸区，伊甸嘛，代表的就是创造）幸存者区，老年代。其中新生代主要放的是一些比较小的，容易回收的对象，当GC来临的时候新生代里面不可回收的对象就会进入幸存者区，新生代里就会清除一次内存，而如果一个对象长时间不回收，它就会进入老年代，老年代的GC是相对惰性的，老年代的GC算法主要是标记整理算法，而一些比较大的对象，放不到新生代里，也会直接进入老年代。设计分区的时候，新生代和幸存者区的内存占用比是8：1：1

## 三、类加载机制

#### 类的加载过程可以分为加载解析初始化这3个过程

**加载**

加载过程主要做了3件事情：

1）根据类的全限定名（即xxx.xxx.x包名加类名）获取二进制字节流

2）将此字节流所代表的静态存储结构转化为方法区的运行时数据结构

3）在内存中生成这个类的class对象，作为方法区这个类的各种数据的访问入口

**验证**

此阶段主要是

1）验证文件格式，比如其中的魔数等

2）元数据验证，验证此类是否有父类，这个类的父类是否继承了不允许继承的类（final修饰的类）如果不是抽象类是否实现了所有的方法，类中的字段、方法是否与父类冲突

3）字节码验证，此过程比较复杂，举例说明，比如声明了一个long的变量却给他赋了一个int的值，这是不允许的，就是在此过程验证。

4）符号引用验证，此阶段发生在虚拟机将符号引用转化为直接引用的时候（发生在解析阶段），比如根据一个字符串描述的全限定名区验证是否能找到对应的类，比如权限关键字修饰的变量是否可被当前类访问。由于我们的开发工具往往在我们写代码的时候就已经做了这件事情，所以这个过程我们一般是不会发生验证不通过的。（除了反射没有去设置access的时候）

**准备**

此阶段为类变量分配内存并赋予初始值。也就是说static修饰的变量其实就是个类变量，在类被加载的时候就会被初始化。而实例变量并不会在类加载过程中被初始化。

**解析**

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，过程有这几个（实际就是符号引用的解析，解析成功就转为直接引用）

1）类或接口的解析，如图前面的验证步骤，解析成功就生成对象。

2）字段解析

```java
public class Demo {
    interface interface0{
        int a = 0;
    }
    interface interface1{
        int a = 1;
    }
    interface interface2{
        int a = 2;
    }
    static class Parent implements interface1{
        public static int a = 3;
    }
    static class Children extends Parent implements interface2{
        public static int a = 4;
    }
    public static void main(String[] args){
        System.out.println(Children.a);
    }
}
```

示例代码中，children的父类和实现的接口都定义了字段a，解析的时候编译器就会报ambiguous的异常，意思就是对这个字段的解释含糊不清，不知道怎么解析。

3）类方法解析

此过程举例：如果method1定义了是个抽象方法，但是他是在一个非抽象类中的方法，那么解析的时候就会失败，再比如引用的是父类的private方法等都会解析失败，符合类型标准就能解析成为一个正常的方法。

4）接口方法解析

不多做赘述。

**初始化**

类初始化阶段是类加载过程的最后一个阶段，静态代码块在这个阶段会根据代码的行数依次执行，怎么样的顺序在前面的程序计数器有讲。举个例子。

```java
public class Demo {
   static {
        field = 1;
        System.out.println(field);
    }
    static int field = 0;
  
}
```

前面讲过，静态字段是在准备阶段就完成了初始化的，所以在静态代码块中，field是可以赋值的，但是他在field定义之前的代码块中却是不可访问的。这段代码会提示非法向前引用而无法编译。

```java
static class Parent {
    public static int a = 3;
   static {
        a = 2;
    }
}
static class Children extends Parent {
    public static int b = Parent.a;
}
public static void main(String[] args){
    System.out.println(Children.b);
}
```

这段代码最后的输出结果会是2，因为父类的初始化阶段将a复制为了2

#### 类加载器

**Java类加载器的分类**

Java的类加载器主要有：

**BootStrap ClassLoader（启动类加载器）**主要负责加载Java虚拟机的核心类库

**Extension ClassLoader(扩展类加载器)** 主要加载扩展的类库，开发者可以直接使用这个加载器。

**Application ClassLoader（应用程序类加载器）** 也叫做系统类加载器，主要负责ClassPath上所指定的类库。他是我们程序中的默认加载器。

**自定义类加载器**

#### 双亲委托模型

Java的类加载使用了双亲委托模型，Java虚拟机的类加载器被要求除了顶层的类加载器外，都必须有一个父加载器，这个规则不是一个强制性的约束。这个模型的工作过程是：当一个类加载器收到了加载一个类的请求，会先去委托给父类去完成这个加载，如果父类加载器能加载，就交给父类加载器，如果父类加载器无法加载这个类，就通过自己去加载。这个模型可以把类和类加载器一起具备了优先级的层级关系。比如我们熟悉的Object，他是由启动类加载器加载的，所以不管是哪个类加载器加载他，用的都是同一个类。

破坏双亲委派模型的需求对于我们Android开发来说，是很难用到的，在此就不作研究了（确实也不会）。